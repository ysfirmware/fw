   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"Eval50xx-Registers.c"
  21              	.Ltext0:
  22              		.align	2
  23              		.global	ReadTMC562Int
  24              		.thumb
  25              		.thumb_func
  27              	ReadTMC562Int:
  28              	.LFB2:
  29              		.file 1 "Eval50xx-Registers.c"
   1:Eval50xx-Registers.c **** /****************************************************
   2:Eval50xx-Registers.c ****   Projekt: TMC562-EVAL
   3:Eval50xx-Registers.c **** 
   4:Eval50xx-Registers.c ****   Modul:   Eval562-Registers.c
   5:Eval50xx-Registers.c ****            Zugriffsfunktionen für den TMC562
   6:Eval50xx-Registers.c **** 
   7:Eval50xx-Registers.c ****   Datum:   26.01.2012 OK
   8:Eval50xx-Registers.c **** *****************************************************/
   9:Eval50xx-Registers.c **** 
  10:Eval50xx-Registers.c **** #include <stdlib.h>
  11:Eval50xx-Registers.c **** #include "stm32f10x_lib.h"
  12:Eval50xx-Registers.c **** #include "bits.h"
  13:Eval50xx-Registers.c **** 
  14:Eval50xx-Registers.c **** #include "Eval50xx.h"
  15:Eval50xx-Registers.c **** #include "Eval50xx-SPI.h"
  16:Eval50xx-Registers.c **** 
  17:Eval50xx-Registers.c **** 
  18:Eval50xx-Registers.c **** //Tabelle, die für jedes TMC562-Register angibt, on dieses auch gelesen werden kann (0=nein, 1=ja).
  19:Eval50xx-Registers.c **** static const UCHAR TMC562RegisterReadable[128]={
  20:Eval50xx-Registers.c **** 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //00..0f
  21:Eval50xx-Registers.c **** 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //10..1f
  22:Eval50xx-Registers.c **** 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,    //20..2f
  23:Eval50xx-Registers.c **** 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0,    //30..3f
  24:Eval50xx-Registers.c **** 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,    //40..4f
  25:Eval50xx-Registers.c **** 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0,    //50..5f
  26:Eval50xx-Registers.c **** 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1,    //60..6f
  27:Eval50xx-Registers.c **** 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1,    //70..7f
  28:Eval50xx-Registers.c **** };
  29:Eval50xx-Registers.c **** 
  30:Eval50xx-Registers.c **** static int TMC562SoftwareCopy[128];    //Software-Kopien aller TMC562-Register (für die nicht lesba
  31:Eval50xx-Registers.c **** 
  32:Eval50xx-Registers.c **** 
  33:Eval50xx-Registers.c **** /*******************************************************************
  34:Eval50xx-Registers.c ****    Funktion: WriteTMC562Datagram()
  35:Eval50xx-Registers.c ****    Parameter: Address: Registeradresse (0x00..0x7f)
  36:Eval50xx-Registers.c ****               x1, x2, x3, x4: Einzelne Bytes des Registers
  37:Eval50xx-Registers.c **** 
  38:Eval50xx-Registers.c ****    Rückgabewert: ---
  39:Eval50xx-Registers.c **** 
  40:Eval50xx-Registers.c ****    Zweck: Schreiben eines TMC562-Registers, wobei der Wert in
  41:Eval50xx-Registers.c ****           einzelnen Bytes angegeben wird.
  42:Eval50xx-Registers.c ****           Die Softwarekopie des Registers wird ebenfalls
  43:Eval50xx-Registers.c ****           aktualisiert.
  44:Eval50xx-Registers.c **** ********************************************************************/
  45:Eval50xx-Registers.c **** void WriteTMC562Datagram(UCHAR Address, UCHAR x1, UCHAR x2, UCHAR x3, UCHAR x4)
  46:Eval50xx-Registers.c **** {
  47:Eval50xx-Registers.c ****   int Value;
  48:Eval50xx-Registers.c **** 
  49:Eval50xx-Registers.c ****   //Register im TMC562 beschreiben
  50:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Address|0x80, FALSE);
  51:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, x1, FALSE);
  52:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, x2, FALSE);
  53:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, x3, FALSE);
  54:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, x4, TRUE);
  55:Eval50xx-Registers.c **** 
  56:Eval50xx-Registers.c ****   //Softwarekopie aktualisieren
  57:Eval50xx-Registers.c ****   Value=x1;
  58:Eval50xx-Registers.c ****   Value<<=8;
  59:Eval50xx-Registers.c ****   Value|=x2;
  60:Eval50xx-Registers.c ****   Value<<=8;
  61:Eval50xx-Registers.c ****   Value|=x3;
  62:Eval50xx-Registers.c ****   Value<<=8;
  63:Eval50xx-Registers.c ****   Value|=x4;
  64:Eval50xx-Registers.c ****   TMC562SoftwareCopy[Address & 0x7f]=Value;
  65:Eval50xx-Registers.c **** }
  66:Eval50xx-Registers.c **** 
  67:Eval50xx-Registers.c **** 
  68:Eval50xx-Registers.c **** /*******************************************************************
  69:Eval50xx-Registers.c ****    Funktion: WriteTMC562Int()
  70:Eval50xx-Registers.c ****    Parameter: Address: Registeradresse (0x00..0x7f)
  71:Eval50xx-Registers.c ****               Value: zu schreibender Wert
  72:Eval50xx-Registers.c **** 
  73:Eval50xx-Registers.c ****    Rückgabewert: ---
  74:Eval50xx-Registers.c **** 
  75:Eval50xx-Registers.c ****    Zweck: Schreiben eines TMC562-Registers.
  76:Eval50xx-Registers.c ****           Die Softwarekopie des Registers wird ebenfalls
  77:Eval50xx-Registers.c ****           aktualisiert.
  78:Eval50xx-Registers.c **** ********************************************************************/
  79:Eval50xx-Registers.c **** void WriteTMC562Int(UCHAR Address, int Value)
  80:Eval50xx-Registers.c **** {
  81:Eval50xx-Registers.c ****   //Register im TMC562 beschreiben
  82:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Address|0x80, FALSE);
  83:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Value >> 24, FALSE);
  84:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Value >> 16, FALSE);
  85:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Value >> 8, FALSE);
  86:Eval50xx-Registers.c ****   ReadWriteSPI(SPI_DEV_TMC50xx, Value & 0xff, TRUE);
  87:Eval50xx-Registers.c **** 
  88:Eval50xx-Registers.c ****   //Softwarekopie aktualisieren
  89:Eval50xx-Registers.c ****   TMC562SoftwareCopy[Address & 0x7f]=Value;
  90:Eval50xx-Registers.c **** }
  91:Eval50xx-Registers.c **** 
  92:Eval50xx-Registers.c **** 
  93:Eval50xx-Registers.c **** /*******************************************************************
  94:Eval50xx-Registers.c ****    Funktion: ReadTMC562Int()
  95:Eval50xx-Registers.c ****    Parameter: Address: Registeradresse (0x00..0x7f)
  96:Eval50xx-Registers.c **** 
  97:Eval50xx-Registers.c ****    Rückgabewert: gelesener Wert
  98:Eval50xx-Registers.c **** 
  99:Eval50xx-Registers.c ****    Zweck: Lesen eines TMC562-Registers.
 100:Eval50xx-Registers.c ****           Falls das Register nicht lesbar ist wird die Softwarekopie
 101:Eval50xx-Registers.c ****           zurückgegeben.
 102:Eval50xx-Registers.c **** ********************************************************************/
 103:Eval50xx-Registers.c **** int ReadTMC562Int(UCHAR Address)
 104:Eval50xx-Registers.c **** {
  30              		.loc 1 104 0
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              	.LVL0:
  34 0000 38B5     		push	{r3, r4, r5, lr}
  35              	.LCFI0:
 105:Eval50xx-Registers.c ****   int Value;
 106:Eval50xx-Registers.c **** 
 107:Eval50xx-Registers.c ****   Address&=0x7f;
 108:Eval50xx-Registers.c ****   if(TMC562RegisterReadable[Address])
  36              		.loc 1 108 0
  37 0002 264B     		ldr	r3, .L7
  38              		.loc 1 107 0
  39 0004 00F07F04 		and	r4, r0, #127
  40              	.LVL1:
  41              		.loc 1 108 0
  42 0008 1B5D     		ldrb	r3, [r3, r4]	@ zero_extendqisi2
  43 000a 002B     		cmp	r3, #0
  44 000c 42D0     		beq	.L2
 109:Eval50xx-Registers.c ****   {
 110:Eval50xx-Registers.c ****     //Register lesbar => aus dem TMC562 lesen.
 111:Eval50xx-Registers.c ****     //Dazu sind zwei Lesezugriffe erforderlich.
 112:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, Address, FALSE);
  45              		.loc 1 112 0
  46 000e 0022     		movs	r2, #0
  47 0010 2146     		mov	r1, r4
  48 0012 0120     		movs	r0, #1
  49 0014 FFF7FEFF 		bl	ReadWriteSPI
 113:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  50              		.loc 1 113 0
  51 0018 0021     		movs	r1, #0
  52 001a 0A46     		mov	r2, r1
  53 001c 0120     		movs	r0, #1
  54 001e FFF7FEFF 		bl	ReadWriteSPI
 114:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  55              		.loc 1 114 0
  56 0022 0021     		movs	r1, #0
  57 0024 0A46     		mov	r2, r1
  58 0026 0120     		movs	r0, #1
  59 0028 FFF7FEFF 		bl	ReadWriteSPI
 115:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  60              		.loc 1 115 0
  61 002c 0021     		movs	r1, #0
  62 002e 0A46     		mov	r2, r1
  63 0030 0120     		movs	r0, #1
  64 0032 FFF7FEFF 		bl	ReadWriteSPI
 116:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, 0, TRUE);
  65              		.loc 1 116 0
  66 0036 0120     		movs	r0, #1
  67 0038 0021     		movs	r1, #0
  68 003a 0246     		mov	r2, r0
  69 003c FFF7FEFF 		bl	ReadWriteSPI
 117:Eval50xx-Registers.c **** 
 118:Eval50xx-Registers.c ****     ReadWriteSPI(SPI_DEV_TMC50xx, Address, FALSE);
  70              		.loc 1 118 0
  71 0040 0022     		movs	r2, #0
  72 0042 2146     		mov	r1, r4
  73 0044 0120     		movs	r0, #1
  74 0046 FFF7FEFF 		bl	ReadWriteSPI
 119:Eval50xx-Registers.c ****     Value=ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  75              		.loc 1 119 0
  76 004a 0021     		movs	r1, #0
  77 004c 0A46     		mov	r2, r1
  78 004e 0120     		movs	r0, #1
  79 0050 FFF7FEFF 		bl	ReadWriteSPI
 120:Eval50xx-Registers.c ****     Value<<=8;
 121:Eval50xx-Registers.c ****     Value|=ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  80              		.loc 1 121 0
  81 0054 0021     		movs	r1, #0
  82              		.loc 1 120 0
  83 0056 0502     		lsls	r5, r0, #8
  84              	.LVL2:
  85              		.loc 1 121 0
  86 0058 0A46     		mov	r2, r1
  87 005a 0120     		movs	r0, #1
  88 005c FFF7FEFF 		bl	ReadWriteSPI
 122:Eval50xx-Registers.c ****     Value<<=8;
 123:Eval50xx-Registers.c ****     Value|=ReadWriteSPI(SPI_DEV_TMC50xx, 0, FALSE);
  89              		.loc 1 123 0
  90 0060 0021     		movs	r1, #0
  91              		.loc 1 121 0
  92 0062 0543     		orrs	r5, r5, r0
  93              	.LVL3:
  94              		.loc 1 123 0
  95 0064 0A46     		mov	r2, r1
  96 0066 0120     		movs	r0, #1
  97 0068 FFF7FEFF 		bl	ReadWriteSPI
  98              		.loc 1 122 0
  99 006c 2D02     		lsls	r5, r5, #8
 100              	.LVL4:
 101              		.loc 1 123 0
 102 006e 0543     		orrs	r5, r5, r0
 103              	.LVL5:
 124:Eval50xx-Registers.c ****     Value<<=8;
 125:Eval50xx-Registers.c ****     Value|=ReadWriteSPI(SPI_DEV_TMC50xx, 0, TRUE);
 104              		.loc 1 125 0
 105 0070 0120     		movs	r0, #1
 106 0072 0021     		movs	r1, #0
 107 0074 0246     		mov	r2, r0
 108              		.loc 1 124 0
 109 0076 2D02     		lsls	r5, r5, #8
 110              	.LVL6:
 111              		.loc 1 125 0
 112 0078 FFF7FEFF 		bl	ReadWriteSPI
 126:Eval50xx-Registers.c **** 
 127:Eval50xx-Registers.c ****     //Register VACTUAL hat nur 24 Bits => Vorzeichenbits erweitern
 128:Eval50xx-Registers.c ****     if(Address==0x22 || Address==0x42)
 113              		.loc 1 128 0
 114 007c 222C     		cmp	r4, #34
 115              		.loc 1 125 0
 116 007e 45EA0000 		orr	r0, r5, r0
 117              	.LVL7:
 118              		.loc 1 128 0
 119 0082 01D0     		beq	.L3
 120 0084 422C     		cmp	r4, #66
 121 0086 08D1     		bne	.L4
 122              	.L3:
 129:Eval50xx-Registers.c ****     {
 130:Eval50xx-Registers.c ****     	if(Value & BIT23) Value|=0xff000000;
 123              		.loc 1 130 0
 124 0088 10F4000F 		tst	r0, #8388608
 125 008c 05D0     		beq	.L4
 126 008e 40F07F40 		orr	r0, r0, #-16777216
 127 0092 02E0     		b	.L4
 128              	.LVL8:
 129              	.L2:
 131:Eval50xx-Registers.c ****     }
 132:Eval50xx-Registers.c **** 
 133:Eval50xx-Registers.c ****     return Value;
 134:Eval50xx-Registers.c ****   }
 135:Eval50xx-Registers.c ****   else
 136:Eval50xx-Registers.c ****   {
 137:Eval50xx-Registers.c ****     //Register nicht lesbar => Softwarekopie zurückgeben
 138:Eval50xx-Registers.c ****     return TMC562SoftwareCopy[Address];
 130              		.loc 1 138 0
 131 0094 024B     		ldr	r3, .L7+4
 132 0096 53F82400 		ldr	r0, [r3, r4, lsl #2]
 133              	.LVL9:
 134              	.L4:
 135              	.LVL10:
 139:Eval50xx-Registers.c ****   }
 140:Eval50xx-Registers.c **** }
 136              		.loc 1 140 0
 137 009a 38BD     		pop	{r3, r4, r5, pc}
 138              	.L8:
 139              		.align	2
 140              	.L7:
 141 009c 00000000 		.word	.LANCHOR0
 142 00a0 00000000 		.word	.LANCHOR1
 143              	.LFE2:
 145              		.align	2
 146              		.global	WriteTMC562Int
 147              		.thumb
 148              		.thumb_func
 150              	WriteTMC562Int:
 151              	.LFB1:
 152              		.loc 1 80 0
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              	.LVL11:
 156 00a4 38B5     		push	{r3, r4, r5, lr}
 157              	.LCFI1:
 158              		.loc 1 82 0
 159 00a6 0022     		movs	r2, #0
 160              		.loc 1 80 0
 161 00a8 0C46     		mov	r4, r1
 162 00aa 0546     		mov	r5, r0
 163              		.loc 1 82 0
 164 00ac 40F08001 		orr	r1, r0, #128
 165              	.LVL12:
 166 00b0 0120     		movs	r0, #1
 167              	.LVL13:
 168 00b2 FFF7FEFF 		bl	ReadWriteSPI
 169              		.loc 1 83 0
 170 00b6 210E     		lsrs	r1, r4, #24
 171 00b8 0022     		movs	r2, #0
 172 00ba 0120     		movs	r0, #1
 173 00bc FFF7FEFF 		bl	ReadWriteSPI
 174              		.loc 1 84 0
 175 00c0 C4F30741 		ubfx	r1, r4, #16, #8
 176 00c4 0022     		movs	r2, #0
 177 00c6 0120     		movs	r0, #1
 178 00c8 FFF7FEFF 		bl	ReadWriteSPI
 179              		.loc 1 85 0
 180 00cc C4F30721 		ubfx	r1, r4, #8, #8
 181 00d0 0022     		movs	r2, #0
 182 00d2 0120     		movs	r0, #1
 183 00d4 FFF7FEFF 		bl	ReadWriteSPI
 184              		.loc 1 86 0
 185 00d8 0120     		movs	r0, #1
 186 00da E1B2     		uxtb	r1, r4
 187 00dc 0246     		mov	r2, r0
 188 00de FFF7FEFF 		bl	ReadWriteSPI
 189              		.loc 1 89 0
 190 00e2 034B     		ldr	r3, .L11
 191 00e4 05F07F05 		and	r5, r5, #127
 192              	.LVL14:
 193 00e8 43F82540 		str	r4, [r3, r5, lsl #2]
 194              		.loc 1 90 0
 195 00ec 38BD     		pop	{r3, r4, r5, pc}
 196              	.L12:
 197 00ee 00BF     		.align	2
 198              	.L11:
 199 00f0 00000000 		.word	.LANCHOR1
 200              	.LFE1:
 202              		.align	2
 203              		.global	WriteTMC562Datagram
 204              		.thumb
 205              		.thumb_func
 207              	WriteTMC562Datagram:
 208              	.LFB0:
 209              		.loc 1 46 0
 210              		@ args = 4, pretend = 0, frame = 0
 211              		@ frame_needed = 0, uses_anonymous_args = 0
 212              	.LVL15:
 213 00f4 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 214              	.LCFI2:
 215              		.loc 1 46 0
 216 00f8 0E46     		mov	r6, r1
 217 00fa 1546     		mov	r5, r2
 218              		.loc 1 50 0
 219 00fc 40F08001 		orr	r1, r0, #128
 220              	.LVL16:
 221              		.loc 1 46 0
 222 0100 0446     		mov	r4, r0
 223              		.loc 1 50 0
 224 0102 0022     		movs	r2, #0
 225              	.LVL17:
 226 0104 0120     		movs	r0, #1
 227              	.LVL18:
 228              		.loc 1 46 0
 229 0106 9846     		mov	r8, r3
 230 0108 9DF81870 		ldrb	r7, [sp, #24]	@ zero_extendqisi2
 231              	.LVL19:
 232              		.loc 1 50 0
 233 010c FFF7FEFF 		bl	ReadWriteSPI
 234              	.LVL20:
 235              		.loc 1 51 0
 236 0110 3146     		mov	r1, r6
 237 0112 0022     		movs	r2, #0
 238 0114 0120     		movs	r0, #1
 239 0116 FFF7FEFF 		bl	ReadWriteSPI
 240              		.loc 1 52 0
 241 011a 2946     		mov	r1, r5
 242 011c 0022     		movs	r2, #0
 243 011e 0120     		movs	r0, #1
 244 0120 FFF7FEFF 		bl	ReadWriteSPI
 245              		.loc 1 53 0
 246 0124 4146     		mov	r1, r8
 247 0126 0022     		movs	r2, #0
 248 0128 0120     		movs	r0, #1
 249 012a FFF7FEFF 		bl	ReadWriteSPI
 250              		.loc 1 54 0
 251 012e 0120     		movs	r0, #1
 252 0130 3946     		mov	r1, r7
 253 0132 0246     		mov	r2, r0
 254              		.loc 1 59 0
 255 0134 45EA0625 		orr	r5, r5, r6, lsl #8
 256              	.LVL21:
 257              		.loc 1 54 0
 258 0138 FFF7FEFF 		bl	ReadWriteSPI
 259              		.loc 1 61 0
 260 013c 48EA0528 		orr	r8, r8, r5, lsl #8
 261              	.LVL22:
 262              		.loc 1 64 0
 263 0140 044B     		ldr	r3, .L15
 264 0142 47EA0827 		orr	r7, r7, r8, lsl #8
 265              	.LVL23:
 266 0146 04F07F04 		and	r4, r4, #127
 267              	.LVL24:
 268 014a 43F82470 		str	r7, [r3, r4, lsl #2]
 269              		.loc 1 65 0
 270 014e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 271              	.L16:
 272 0152 00BF     		.align	2
 273              	.L15:
 274 0154 00000000 		.word	.LANCHOR1
 275              	.LFE0:
 277              		.section	.rodata
 278              		.align	2
 279              		.set	.LANCHOR0,. + 0
 282              	TMC562RegisterReadable:
 283 0000 01       		.byte	1
 284 0001 01       		.byte	1
 285 0002 01       		.byte	1
 286 0003 00       		.byte	0
 287 0004 01       		.byte	1
 288 0005 00       		.byte	0
 289 0006 00       		.byte	0
 290 0007 00       		.byte	0
 291 0008 00       		.byte	0
 292 0009 00       		.byte	0
 293 000a 00       		.byte	0
 294 000b 00       		.byte	0
 295 000c 00       		.byte	0
 296 000d 00       		.byte	0
 297 000e 00       		.byte	0
 298 000f 00       		.byte	0
 299 0010 00       		.byte	0
 300 0011 00       		.byte	0
 301 0012 00       		.byte	0
 302 0013 00       		.byte	0
 303 0014 00       		.byte	0
 304 0015 00       		.byte	0
 305 0016 00       		.byte	0
 306 0017 00       		.byte	0
 307 0018 00       		.byte	0
 308 0019 00       		.byte	0
 309 001a 00       		.byte	0
 310 001b 00       		.byte	0
 311 001c 00       		.byte	0
 312 001d 00       		.byte	0
 313 001e 00       		.byte	0
 314 001f 00       		.byte	0
 315 0020 01       		.byte	1
 316 0021 01       		.byte	1
 317 0022 01       		.byte	1
 318 0023 00       		.byte	0
 319 0024 00       		.byte	0
 320 0025 00       		.byte	0
 321 0026 00       		.byte	0
 322 0027 00       		.byte	0
 323 0028 00       		.byte	0
 324 0029 00       		.byte	0
 325 002a 00       		.byte	0
 326 002b 00       		.byte	0
 327 002c 00       		.byte	0
 328 002d 01       		.byte	1
 329 002e 00       		.byte	0
 330 002f 00       		.byte	0
 331 0030 00       		.byte	0
 332 0031 00       		.byte	0
 333 0032 00       		.byte	0
 334 0033 00       		.byte	0
 335 0034 01       		.byte	1
 336 0035 01       		.byte	1
 337 0036 01       		.byte	1
 338 0037 00       		.byte	0
 339 0038 01       		.byte	1
 340 0039 01       		.byte	1
 341 003a 00       		.byte	0
 342 003b 01       		.byte	1
 343 003c 01       		.byte	1
 344 003d 00       		.byte	0
 345 003e 00       		.byte	0
 346 003f 00       		.byte	0
 347 0040 01       		.byte	1
 348 0041 01       		.byte	1
 349 0042 01       		.byte	1
 350 0043 00       		.byte	0
 351 0044 00       		.byte	0
 352 0045 00       		.byte	0
 353 0046 00       		.byte	0
 354 0047 00       		.byte	0
 355 0048 00       		.byte	0
 356 0049 00       		.byte	0
 357 004a 00       		.byte	0
 358 004b 00       		.byte	0
 359 004c 00       		.byte	0
 360 004d 01       		.byte	1
 361 004e 00       		.byte	0
 362 004f 00       		.byte	0
 363 0050 00       		.byte	0
 364 0051 00       		.byte	0
 365 0052 00       		.byte	0
 366 0053 00       		.byte	0
 367 0054 01       		.byte	1
 368 0055 01       		.byte	1
 369 0056 01       		.byte	1
 370 0057 00       		.byte	0
 371 0058 01       		.byte	1
 372 0059 01       		.byte	1
 373 005a 00       		.byte	0
 374 005b 01       		.byte	1
 375 005c 01       		.byte	1
 376 005d 00       		.byte	0
 377 005e 00       		.byte	0
 378 005f 00       		.byte	0
 379 0060 00       		.byte	0
 380 0061 00       		.byte	0
 381 0062 00       		.byte	0
 382 0063 00       		.byte	0
 383 0064 00       		.byte	0
 384 0065 00       		.byte	0
 385 0066 00       		.byte	0
 386 0067 00       		.byte	0
 387 0068 00       		.byte	0
 388 0069 00       		.byte	0
 389 006a 01       		.byte	1
 390 006b 01       		.byte	1
 391 006c 01       		.byte	1
 392 006d 00       		.byte	0
 393 006e 00       		.byte	0
 394 006f 01       		.byte	1
 395 0070 00       		.byte	0
 396 0071 00       		.byte	0
 397 0072 00       		.byte	0
 398 0073 00       		.byte	0
 399 0074 00       		.byte	0
 400 0075 00       		.byte	0
 401 0076 00       		.byte	0
 402 0077 00       		.byte	0
 403 0078 00       		.byte	0
 404 0079 00       		.byte	0
 405 007a 01       		.byte	1
 406 007b 01       		.byte	1
 407 007c 01       		.byte	1
 408 007d 00       		.byte	0
 409 007e 00       		.byte	0
 410 007f 01       		.byte	1
 411              		.bss
 412              		.align	2
 413              		.set	.LANCHOR1,. + 0
 416              	TMC562SoftwareCopy:
 417 0000 00000000 		.space	512
 417      00000000 
 417      00000000 
 417      00000000 
 417      00000000 
 512              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 Eval50xx-Registers.c
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:22     .text:00000000 $t
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:27     .text:00000000 ReadTMC562Int
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:141    .text:0000009c $d
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:145    .text:000000a4 $t
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:150    .text:000000a4 WriteTMC562Int
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:199    .text:000000f0 $d
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:202    .text:000000f4 $t
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:207    .text:000000f4 WriteTMC562Datagram
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:274    .text:00000154 $d
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:278    .rodata:00000000 $d
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:282    .rodata:00000000 TMC562RegisterReadable
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:412    .bss:00000000 $d
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:416    .bss:00000000 TMC562SoftwareCopy
C:\DOKUME~1\Kahlbaum\LOKALE~1\Temp\cccvY5bb.s:431    .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ReadWriteSPI
